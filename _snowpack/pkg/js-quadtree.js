class c{constructor(t,s,e,i,h){this.x=t,this.y=s,this.w=e,this.h=i,this.data=h}contains(t){return t.x>=this.x&&t.x<=this.x+this.w&&t.y>=this.y&&t.y<=this.y+this.h}intersects(t){return!(t.x>this.x+this.w||t.x+t.w<this.x||t.y>this.y+this.h||t.y+t.h<this.y)}}class u{constructor(t,s,e,i){this.x=t,this.y=s,this.r=e,this.rPow2=this.r*this.r,this.data=i}euclideanDistancePow2(t,s){return Math.pow(t.x-s.x,2)+Math.pow(t.y-s.y,2)}contains(t){return this.euclideanDistancePow2(t,this)<=this.rPow2}intersects(t){const s=this.x-Math.max(t.x,Math.min(this.x,t.x+t.w)),e=this.y-Math.max(t.y,Math.min(this.y,t.y+t.h));return s*s+e*e<=this.rPow2}}class a{constructor(t,s,e){this.x=t,this.y=s,this.data=e}}const d={capacity:4,removeEmptyNodes:!1,maximumDepth:-1,arePointsEqual:(o,t)=>o.x===t.x&&o.y===t.y};class r{constructor(t,s,e=[]){this.container=t,this.config=Object.assign({},d,s),this.isDivided=!1,this.points=[];for(const i of e)this.insertRecursive(i)}getTree(){let t;return t=this.isDivided?{ne:this.ne.getTree(),nw:this.nw.getTree(),se:this.se.getTree(),sw:this.sw.getTree()}:this.getNodePointAmount(),t}getAllPoints(){const t=[];return this.getAllPointsRecursive(t),t}getAllPointsRecursive(t){this.isDivided?(this.ne.getAllPointsRecursive(t),this.nw.getAllPointsRecursive(t),this.se.getAllPointsRecursive(t),this.sw.getAllPointsRecursive(t)):Array.prototype.push.apply(t,this.points.slice())}getNodePointAmount(){return this.points.length}divide(){const t=this.config.maximumDepth===-1?-1:this.config.maximumDepth-1,s=Object.assign({},this.config,{maximumDepth:t});this.isDivided=!0;const e=this.container.x,i=this.container.y,h=this.container.w/2,n=this.container.h/2;this.ne=new r(new c(e+h,i,h,n),s),this.nw=new r(new c(e,i,h,n),s),this.se=new r(new c(e+h,i+n,h,n),s),this.sw=new r(new c(e,i+n,h,n),s),this.insert(this.points.slice()),this.points.length=0,this.points=[]}remove(t){if(Array.isArray(t))for(const s of t)this.removeRecursive(s);else this.removeRecursive(t)}removeRecursive(t){if(this.container.contains(t))if(this.isDivided)this.ne.removeRecursive(t),this.nw.removeRecursive(t),this.se.removeRecursive(t),this.sw.removeRecursive(t),this.config.removeEmptyNodes&&(this.ne.getNodePointAmount()!==0||this.ne.isDivided||this.nw.getNodePointAmount()!==0||this.nw.isDivided||this.se.getNodePointAmount()!==0||this.se.isDivided||this.sw.getNodePointAmount()!==0||this.sw.isDivided||(this.isDivided=!1,delete this.ne,delete this.nw,delete this.se,delete this.sw));else for(let s=this.points.length-1;s>=0;s--)this.config.arePointsEqual(t,this.points[s])&&this.points.splice(s,1)}insert(t){if(Array.isArray(t)){let s=!0;for(const e of t)s=s&&this.insertRecursive(e);return s}return this.insertRecursive(t)}insertRecursive(t){if(!this.container.contains(t))return!1;if(!this.isDivided){if(this.getNodePointAmount()<this.config.capacity||this.config.maximumDepth===0)return this.points.push(t),!0;(this.config.maximumDepth===-1||this.config.maximumDepth>0)&&this.divide()}return!!this.isDivided&&(this.ne.insertRecursive(t)||this.nw.insertRecursive(t)||this.se.insertRecursive(t)||this.sw.insertRecursive(t))}query(t){const s=[];return this.queryRecursive(t,s),s}queryRecursive(t,s){if(t.intersects(this.container))if(this.isDivided)this.ne.queryRecursive(t,s),this.nw.queryRecursive(t,s),this.se.queryRecursive(t,s),this.sw.queryRecursive(t,s);else{const e=this.points.filter(i=>t.contains(i));Array.prototype.push.apply(s,e)}}clear(){this.points=[],this.isDivided=!1,delete this.ne,delete this.nw,delete this.se,delete this.sw}}export{c as Box,u as Circle,a as Point,r as QuadTree};
