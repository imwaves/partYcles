import o from"./snowpack/pkg/ish-utils/PVector.js";import{rand as a}from"./snowpack/pkg/ish-utils/math.js";import{checkEdges as E,checkEdgesMirror as F}from"./utils/common.js";import"./snowpack/pkg/simplex-noise.js";import*as d from"./snowpack/pkg/js-quadtree.js";import x from"./TurbulenceField.js";console.log("worker.js","Inited");let b=new d.QuadTree,M=!1;const P={capacity:8,maximumDepth:15},q=new x({mult:.1,scale:.0035,seed:a(0,1e6)});let v=0,i=[],n={distance:85,mult:1,mirrorEdges:!1,attract:!0,amount:500,flock:1,align:1,wind:0,gravity:0,amount:0,turbulence:!1,turbMorph:1,quadTree:!0};const R=45/180*Math.PI;let Q=0;class k{constructor(t){Object.assign(this,t),this.id=Q++,!this.vel&&(this.vel=new o(0,0)),!this.acc&&(this.acc=new o(0,0)),!this.pos&&(this.pos=new o(0,0)),this.lastPos=new o(this.pos)}applyForce(t){this.acc.add(t)}attract(t){let p=new o(this.pos).sub(t.pos);const r=p.mag();if(r>w/4)return;const h=(r<n.distance?6*n.align:-16*n.flock)*n.mult/(r*r);p.norm().mult(h),this.applyForce(p)}update(){this.lastPos=new o(this.pos),this.vel.add(this.acc).maxMag(2*Math.sqrt(n.mult)),this.pos.add(new o(this.vel).mult(1)),this.acc.set(0,0)}}let l,c,w,f=0;const W=new o(0,.01);let T=0;const C={twoPoints(s){let t;return l>c?t=new o(a()<.5?l/3+a(-1,1):l/3*2+a(-1,1),c/2+a(-1,1)):t=new o(l/2+a(-1,1),a()<.5?c/3+a(-1,1):c/3*2+a(-1,1)),new k({pos:t,vel:new o(a(-1,1),a(-1,1)),acc:new o(0,0)})},voidCircle(s){const t=Math.PI*32/n.amount,p=w/1.2,r=new o(Math.sin(t*s)*Math.sin(t*s/10)*p+l/2,Math.cos(t*s)*Math.sin(t*s/10)*p+c/2),h=o.fromAngle(-t*s).mult(30);return new k({pos:r})}},j={init(s){j.resize(s);const{width:t=l,height:p=c,amount:r=n.amount,arrangement:h="twoPoints"}=s;n.amount=r,f=0,i.length=0;for(let e=0;e<r;e++)i.push(C[h](e));return i},resize({width:s,height:t}){l=s,c=t,w=Math.min(l,c)},params(s){Object.assign(n,s)},update({mouse:s}){let t=new o(n.wind/80,n.gravity/80);t=t.mag()&&t,n.turbulence&&(v+=n.turbMorph/7);let p=w/4;s&&(T=f),M=n.turbulence&&f>100&&!s&&f-T>100,M&&(b=new d.QuadTree(new d.Box(0,0,l,c),P),i.forEach((e,g)=>{b.insert(new d.Point(e.pos.x,e.pos.y,g))}));let r=0;i.forEach((e,g)=>{if(s){const u=o.sub(new o(s),e.pos),m=u.mag();e.applyForce(u.norm().mult(.1*Math.sqrt(m/10)))}if(n.attract)if(M){const u=b.query(new d.Circle(e.pos.x,e.pos.y,p));for(let m=0;m<u.length;m++){const y=i[u[m].data];e!==y&&e.attract(y)}}else for(let u=0;u<i.length;u++){const m=i[u];u!==g&&e.attract(m)}const S=240;if(n.turbulence){const u=q.getForce({...e.pos,z:v},{bound:240,W:l,H:c});e.applyForce(u)}n.mirrorEdges?E(e,l,c):F(e,l,c),t&&e.applyForce(t),e.update()});const h=n.amount-i.length;if(h<0)i=i.slice(-h);else if(h>0)for(let e=0;e<h;e++)i.push(new k({pos:new o(a(0,l-1),a(0,c-1)),vel:new o(a(-1,1),a(-1,1))}));return f++,i}};self.onmessage=({data:{cmd:s,data:t,cmdId:p}})=>{const r=j[s](t);r&&self.postMessage({cmd:s,data:r,cmdId:p})};
