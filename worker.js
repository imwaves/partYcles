import o from"./snowpack/pkg/ish-utils/PVector.js";import{rand as l,smoothstep as _,clamp as C,doubleExponentialSigmoid as Q}from"./snowpack/pkg/ish-utils/math.js";import{checkEdges as I,checkEdgesMirror as N}from"./utils/common.js";import O from"./snowpack/pkg/simplex-noise.js";import*as f from"./snowpack/pkg/js-quadtree.js";console.log("worker.js","asdfasdfasdf");let k=new f.QuadTree,x=!1;const D={capacity:8,maximumDepth:15},z=new O(l(0,1e6));let b=.05,w,T,j=.07,v=[],A=0,U=0,u=[],a={distance:85,mult:1,mirrorEdges:!1,attract:!0,amount:500,flock:1,align:1,wind:0,gravity:0,amount:0,turbulence:!1,turbField:null,turbMorph:1,quadTree:!0};const X=45/180*Math.PI;let H=0;class F{constructor(t){Object.assign(this,t),this.id=H++,!this.vel&&(this.vel=new o(0,0)),!this.acc&&(this.acc=new o(0,0)),!this.pos&&(this.pos=new o(0,0)),this.lastPos=new o(this.pos)}applyForce(t){this.acc.add(t)}attract(t){let i=new o(this.pos).sub(t.pos);const n=i.mag();if(n>M/4)return;const h=(n<a.distance?6*a.align:-16*a.flock)*a.mult/(n*n);i.norm().mult(h),this.applyForce(i)}update(){this.lastPos=new o(this.pos),this.vel.add(this.acc).maxMag(2*Math.sqrt(a.mult)),this.pos.add(new o(this.vel).mult(1)),this.acc.set(0,0)}}let r,p,M,g=0;const Y=new o(0,.01);let S=0;const L={twoPoints(s){let t;return r>p?t=new o(l()<.5?r/3+l(-1,1):r/3*2+l(-1,1),p/2+l(-1,1)):t=new o(r/2+l(-1,1),l()<.5?p/3+l(-1,1):p/3*2+l(-1,1)),new F({pos:t,vel:new o(l(-1,1),l(-1,1)),acc:new o(0,0)})},voidCircle(s){const t=Math.PI*32/a.amount,i=M/1.2,n=new o(Math.sin(t*s)*Math.sin(t*s/10)*i+r/2,Math.cos(t*s)*Math.sin(t*s/10)*i+p/2),h=o.fromAngle(-t*s).mult(30);return new F({pos:n})}},q={init(s){q.resize(s);const{width:t=r,height:i=p,amount:n=a.amount,arrangement:h="twoPoints"}=s;a.amount=n,g=0,this.setTurbField(),u.length=0;for(let e=0;e<n;e++)u.push(L[h](e));return u},setTurbField(){if(a.turbMorph===0)return;const s=Array(21).fill(0);w=Math.ceil(r*b),T=Math.ceil(p*b),v=Array(w*T);for(let t=0;t<=w;t++)for(let i=0;i<=T;i++){let n=z.noise3D(t*j,i*j,A*5e-4);a.mirrorEdges&&(n=Q((n+1)/2,.45)*2-1,n=C(-1,1,n*1.1)),s[Math.round((n+1)*10)]++,v[t*w+i]=o.fromAngle(n*Math.PI).mult(.3)}A+=a.turbMorph},resize({width:s,height:t}){r=s,p=t,M=Math.min(r,p)},params(s){Object.assign(a,s)},update({mouse:s}){let t=new o(a.wind/80,a.gravity/80);t=t.mag()&&t,a.turbulence&&this.setTurbField();let i=M/4;s&&(S=g),x=a.turbulence&&g>100&&!s&&g-S>100,x&&(k=new f.QuadTree(new f.Box(0,0,r,p),D),u.forEach((e,y)=>{k.insert(new f.Point(e.pos.x,e.pos.y,y))}));let n=0;u.forEach((e,y)=>{if(s){const c=o.sub(new o(s),e.pos),m=c.mag();e.applyForce(c.norm().mult(.1*Math.sqrt(m/10)))}if(a.attract)if(x){const c=k.query(new f.Circle(e.pos.x,e.pos.y,i));for(let m=0;m<c.length;m++){const d=u[c[m].data];e!==d&&e.attract(d)}}else for(let c=0;c<u.length;c++){const m=u[c];c!==y&&e.attract(m)}const E=240;if(a.turbulence){const c=e.pos.x*b|0,m=e.pos.y*b|0,d=v[c*w+m]||new o(0,0),P=r/2-Math.abs(r/2-e.pos.x);P<E&&d.mult(1-_(r/2-E,r/2,P)/E),e.applyForce(d)}a.mirrorEdges?I(e,r,p):N(e,r,p),t&&e.applyForce(t),e.update()});const h=a.amount-u.length;if(h<0)u=u.slice(-h);else if(h>0)for(let e=0;e<h;e++)u.push(new F({pos:new o(l(0,r-1),l(0,p-1)),vel:new o(l(-1,1),l(-1,1))}));return g++,u}};self.onmessage=({data:{cmd:s,data:t,cmdId:i}})=>{const n=q[s](t);n&&self.postMessage({cmd:s,data:n,cmdId:i})};
